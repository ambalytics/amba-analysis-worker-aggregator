{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"amba-analysis-worker-aggregator setup influx (if needed) send data points to influx db do trend calculations (using influx) save in postgres","title":"Home"},{"location":"#amba-analysis-worker-aggregator","text":"setup influx (if needed) send data points to influx db do trend calculations (using influx) save in postgres","title":"amba-analysis-worker-aggregator"},{"location":"aggregator_ref/","text":"get_doi_list_trending ( trending ) Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: Source code in src/aggregator.py def get_doi_list_trending ( trending ): \"\"\" Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: \"\"\" p = { \"_bucket\" : trending [ 'name' ], \"_min_count\" : trending [ 'min_count' ], \"_start\" : trending [ 'duration' ], } # |> range(start: 2021-09-24T14:00:00Z, stop: 2021-09-24T19:00:00Z) query = \"\"\" _stop = now() countTable = from(bucket: _bucket) |> range(start: _start, stop: _stop) |> filter(fn: (r) => r[\"_measurement\"] == \"trending\") |> filter(fn: (r) => r[\"_field\"] == \"score\") |> count() |> filter(fn: (r) => r[\"_value\"] > _min_count) |> group() |> keep(columns: [\"doi\"]) |> yield() \"\"\" result = query_api . query ( org = org , query = query , params = p ) results = [] for table in result : for record in table . records : results . append ( record [ 'doi' ]) # print(results) return results trend_calc_currently () async run trend calculation in the defined interval Source code in src/aggregator.py @app . timer ( interval = trending_time_definition [ 'currently' ][ 'trending_interval' ]) async def trend_calc_currently (): \"\"\" run trend calculation in the defined interval \"\"\" print ( 'calc trend currently' ) await run_trend_calculation ( trending_time_definition [ 'currently' ])","title":"aggregator"},{"location":"aggregator_ref/#aggregator.get_doi_list_trending","text":"Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: Source code in src/aggregator.py def get_doi_list_trending ( trending ): \"\"\" Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: \"\"\" p = { \"_bucket\" : trending [ 'name' ], \"_min_count\" : trending [ 'min_count' ], \"_start\" : trending [ 'duration' ], } # |> range(start: 2021-09-24T14:00:00Z, stop: 2021-09-24T19:00:00Z) query = \"\"\" _stop = now() countTable = from(bucket: _bucket) |> range(start: _start, stop: _stop) |> filter(fn: (r) => r[\"_measurement\"] == \"trending\") |> filter(fn: (r) => r[\"_field\"] == \"score\") |> count() |> filter(fn: (r) => r[\"_value\"] > _min_count) |> group() |> keep(columns: [\"doi\"]) |> yield() \"\"\" result = query_api . query ( org = org , query = query , params = p ) results = [] for table in result : for record in table . records : results . append ( record [ 'doi' ]) # print(results) return results","title":"get_doi_list_trending()"},{"location":"aggregator_ref/#aggregator.trend_calc_currently","text":"run trend calculation in the defined interval Source code in src/aggregator.py @app . timer ( interval = trending_time_definition [ 'currently' ][ 'trending_interval' ]) async def trend_calc_currently (): \"\"\" run trend calculation in the defined interval \"\"\" print ( 'calc trend currently' ) await run_trend_calculation ( trending_time_definition [ 'currently' ])","title":"trend_calc_currently()"}]}
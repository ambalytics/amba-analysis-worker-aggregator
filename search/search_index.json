{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"amba-analysis-worker-aggregator setup influx (if needed) send data points to influx db do trend calculations (using influx) save in postgres","title":"Home"},{"location":"#amba-analysis-worker-aggregator","text":"setup influx (if needed) send data points to influx db do trend calculations (using influx) save in postgres","title":"amba-analysis-worker-aggregator"},{"location":"aggregator_ref/","text":"get_doi_list_trending ( trending ) Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: Source code in src/aggregator.py def get_doi_list_trending ( trending ): \"\"\" Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: \"\"\" p = { \"_bucket\" : trending [ 'name' ], \"_min_count\" : trending [ 'min_count' ], \"_start\" : trending [ 'duration' ], } # |> range(start: 2021-09-24T14:00:00Z, stop: 2021-09-24T19:00:00Z) query = \"\"\" _stop = now() countTable = from(bucket: _bucket) |> range(start: _start, stop: _stop) |> filter(fn: (r) => r[\"_measurement\"] == \"trending\") |> filter(fn: (r) => r[\"_field\"] == \"score\") |> count() |> filter(fn: (r) => r[\"_value\"] > _min_count) |> group() |> keep(columns: [\"doi\"]) |> yield() \"\"\" result = query_api . query ( org = org , query = query , params = p ) results = [] for table in result : for record in table . records : results . append ( record [ 'doi' ]) # print(results) return results hot_papers () get only papers that have covid as a top3 entity Source code in src/aggregator.py def hot_papers (): \"\"\" get only papers that have covid as a top3 entity \"\"\" query = \"SELECT * FROM trending_covid_papers WHERE duration = 'today' ORDER BY trending_ranking LIMIT 3;\" s = text ( query ) session_factory = sessionmaker ( bind = DAO . engine ) Session = scoped_session ( session_factory ) session = Session () result = session . execute ( s ) . fetchall () length = 40 end = 4 pretext = \"\" while end > 0 : pretext = 'Todays trending COVID-19 papers:' for r in result : pretext += \" \\n \" + str ( r [ 'trending_ranking' ]) + '. ' + r [ 'name' ] . split ( ' ' )[ - 1 ] + ' et al. ' \\ + smart_truncate ( r [ 'title' ], length ) pretext += ' \\n https://bit.ly/3m4YoWR' if len ( pretext ) > 280 : length -= 10 else : break end -= 1 print ( pretext ) print ( len ( pretext )) if 100 < len ( pretext ) < 280 : consumer_key = os . environ . get ( 'CONSUMER_KEY_TWITTER_BOT' ) consumer_secret = os . environ . get ( 'CONSUMER_SECRET_TWITTER_BOT' ) access_token = os . environ . get ( 'ACCESS_TOKEN_TWITTER_BOT' ) access_token_secret = os . environ . get ( 'ACCESS_TOKEN_SECRET_TWITTER_BOT' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) print ( api . verify_credentials () . name ) api . update_status ( status = pretext ) return True trend_calc_currently () async run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '*/3 * * * *' ) async def trend_calc_currently (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend currently' ) await run_trend_calculation ( trending_time_definition [ 'currently' ]) trend_calc_month () async run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '5 */3 * * *' ) async def trend_calc_month (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend month' ) await run_trend_calculation ( trending_time_definition [ 'month' ]) trend_calc_today () async run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '1-59/10 * * * *' ) async def trend_calc_today (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend today' ) await run_trend_calculation ( trending_time_definition [ 'today' ]) trend_calc_week () async run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '25 * * * *' ) async def trend_calc_week (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend week' ) await run_trend_calculation ( trending_time_definition [ 'week' ]) trend_calc_year () async run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '4 2 * * *' ) async def trend_calc_year (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend year' ) await run_trend_calculation ( trending_time_definition [ 'year' ])","title":"aggregator"},{"location":"aggregator_ref/#aggregator.get_doi_list_trending","text":"Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: Source code in src/aggregator.py def get_doi_list_trending ( trending ): \"\"\" Return a list of dois that have the required min count for the trending definition given. It will use the count of datapoints not the actual tweet count. :param trending: :return: \"\"\" p = { \"_bucket\" : trending [ 'name' ], \"_min_count\" : trending [ 'min_count' ], \"_start\" : trending [ 'duration' ], } # |> range(start: 2021-09-24T14:00:00Z, stop: 2021-09-24T19:00:00Z) query = \"\"\" _stop = now() countTable = from(bucket: _bucket) |> range(start: _start, stop: _stop) |> filter(fn: (r) => r[\"_measurement\"] == \"trending\") |> filter(fn: (r) => r[\"_field\"] == \"score\") |> count() |> filter(fn: (r) => r[\"_value\"] > _min_count) |> group() |> keep(columns: [\"doi\"]) |> yield() \"\"\" result = query_api . query ( org = org , query = query , params = p ) results = [] for table in result : for record in table . records : results . append ( record [ 'doi' ]) # print(results) return results","title":"get_doi_list_trending()"},{"location":"aggregator_ref/#aggregator.hot_papers","text":"get only papers that have covid as a top3 entity Source code in src/aggregator.py def hot_papers (): \"\"\" get only papers that have covid as a top3 entity \"\"\" query = \"SELECT * FROM trending_covid_papers WHERE duration = 'today' ORDER BY trending_ranking LIMIT 3;\" s = text ( query ) session_factory = sessionmaker ( bind = DAO . engine ) Session = scoped_session ( session_factory ) session = Session () result = session . execute ( s ) . fetchall () length = 40 end = 4 pretext = \"\" while end > 0 : pretext = 'Todays trending COVID-19 papers:' for r in result : pretext += \" \\n \" + str ( r [ 'trending_ranking' ]) + '. ' + r [ 'name' ] . split ( ' ' )[ - 1 ] + ' et al. ' \\ + smart_truncate ( r [ 'title' ], length ) pretext += ' \\n https://bit.ly/3m4YoWR' if len ( pretext ) > 280 : length -= 10 else : break end -= 1 print ( pretext ) print ( len ( pretext )) if 100 < len ( pretext ) < 280 : consumer_key = os . environ . get ( 'CONSUMER_KEY_TWITTER_BOT' ) consumer_secret = os . environ . get ( 'CONSUMER_SECRET_TWITTER_BOT' ) access_token = os . environ . get ( 'ACCESS_TOKEN_TWITTER_BOT' ) access_token_secret = os . environ . get ( 'ACCESS_TOKEN_SECRET_TWITTER_BOT' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) print ( api . verify_credentials () . name ) api . update_status ( status = pretext ) return True","title":"hot_papers()"},{"location":"aggregator_ref/#aggregator.trend_calc_currently","text":"run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '*/3 * * * *' ) async def trend_calc_currently (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend currently' ) await run_trend_calculation ( trending_time_definition [ 'currently' ])","title":"trend_calc_currently()"},{"location":"aggregator_ref/#aggregator.trend_calc_month","text":"run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '5 */3 * * *' ) async def trend_calc_month (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend month' ) await run_trend_calculation ( trending_time_definition [ 'month' ])","title":"trend_calc_month()"},{"location":"aggregator_ref/#aggregator.trend_calc_today","text":"run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '1-59/10 * * * *' ) async def trend_calc_today (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend today' ) await run_trend_calculation ( trending_time_definition [ 'today' ])","title":"trend_calc_today()"},{"location":"aggregator_ref/#aggregator.trend_calc_week","text":"run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '25 * * * *' ) async def trend_calc_week (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend week' ) await run_trend_calculation ( trending_time_definition [ 'week' ])","title":"trend_calc_week()"},{"location":"aggregator_ref/#aggregator.trend_calc_year","text":"run trend calculation in the defined interval Source code in src/aggregator.py @app . crontab ( '4 2 * * *' ) async def trend_calc_year (): \"\"\"run trend calculation in the defined interval\"\"\" print ( 'calc trend year' ) await run_trend_calculation ( trending_time_definition [ 'year' ])","title":"trend_calc_year()"}]}
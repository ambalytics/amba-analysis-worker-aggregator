{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"amba-analysis-worker-aggregator Aggregates events","title":"Home"},{"location":"#amba-analysis-worker-aggregator","text":"Aggregates events","title":"amba-analysis-worker-aggregator"},{"location":"aggregator_ref/","text":"Event __lt__ ( self , other ) special we want an element to be sorted by score Source code in src/aggregator.py def __lt__ ( self , other ): \"\"\" we want an element to be sorted by score \"\"\" return self . get_score () < other . get_score () get_score ( self ) get score of this event Source code in src/aggregator.py def get_score ( self ): \"\"\" get score of this event \"\"\" return self . subj . processed . score TrendingHeap use a heapdict of fixed size to store the top events more for heapdict: https://www.geeksforgeeks.org/priority-queue-using-queue-and-heapdict-module-in-python/ __init__ ( self ) special init an empty heapdict Source code in src/aggregator.py def __init__ ( self ): \"\"\" init an empty heapdict \"\"\" self . heap = heapdict . heapdict () contains ( self , key ) check if an event is already in this heap Source code in src/aggregator.py def contains ( self , key ): \"\"\" check if an event is already in this heap \"\"\" if key in self . heap : return True return False get_items ( self ) return the item in the heap Source code in src/aggregator.py def get_items ( self ): \"\"\" return the item in the heap \"\"\" return self . heap . items () get_lowest_score ( self ) return the lowest score in this heap Source code in src/aggregator.py def get_lowest_score ( self ): \"\"\" return the lowest score in this heap \"\"\" return self . heap . peekitem ()[ 1 ] is_empty ( self ) check if heap is empty Source code in src/aggregator.py def is_empty ( self ): \"\"\" check if heap is empty \"\"\" return len ( self . heap ) == 0 is_full ( self ) check if heap is full, meaning its length is the desired size Source code in src/aggregator.py def is_full ( self ): \"\"\" check if heap is full, meaning its length is the desired size \"\"\" return len ( self . heap ) == self . size update ( self , key , score ) update the heapdict, return true if changes, false if not return true if full and update happened Source code in src/aggregator.py def update ( self , key , score ): \"\"\" update the heapdict, return true if changes, false if not return true if full and update happened \"\"\" if self . contains ( key ): self . heap [ key ] = score return self . is_full () else : if not self . is_full (): self . heap [ key ] = score return self . is_full () else : if score > self . get_lowest_score (): self . heap . popitem () self . heap [ key ] = score return self . is_full () return False","title":"aggregator"},{"location":"aggregator_ref/#aggregator.Event","text":"","title":"Event"},{"location":"aggregator_ref/#aggregator.Event.__lt__","text":"we want an element to be sorted by score Source code in src/aggregator.py def __lt__ ( self , other ): \"\"\" we want an element to be sorted by score \"\"\" return self . get_score () < other . get_score ()","title":"__lt__()"},{"location":"aggregator_ref/#aggregator.Event.get_score","text":"get score of this event Source code in src/aggregator.py def get_score ( self ): \"\"\" get score of this event \"\"\" return self . subj . processed . score","title":"get_score()"},{"location":"aggregator_ref/#aggregator.TrendingHeap","text":"use a heapdict of fixed size to store the top events more for heapdict: https://www.geeksforgeeks.org/priority-queue-using-queue-and-heapdict-module-in-python/","title":"TrendingHeap"},{"location":"aggregator_ref/#aggregator.TrendingHeap.__init__","text":"init an empty heapdict Source code in src/aggregator.py def __init__ ( self ): \"\"\" init an empty heapdict \"\"\" self . heap = heapdict . heapdict ()","title":"__init__()"},{"location":"aggregator_ref/#aggregator.TrendingHeap.contains","text":"check if an event is already in this heap Source code in src/aggregator.py def contains ( self , key ): \"\"\" check if an event is already in this heap \"\"\" if key in self . heap : return True return False","title":"contains()"},{"location":"aggregator_ref/#aggregator.TrendingHeap.get_items","text":"return the item in the heap Source code in src/aggregator.py def get_items ( self ): \"\"\" return the item in the heap \"\"\" return self . heap . items ()","title":"get_items()"},{"location":"aggregator_ref/#aggregator.TrendingHeap.get_lowest_score","text":"return the lowest score in this heap Source code in src/aggregator.py def get_lowest_score ( self ): \"\"\" return the lowest score in this heap \"\"\" return self . heap . peekitem ()[ 1 ]","title":"get_lowest_score()"},{"location":"aggregator_ref/#aggregator.TrendingHeap.is_empty","text":"check if heap is empty Source code in src/aggregator.py def is_empty ( self ): \"\"\" check if heap is empty \"\"\" return len ( self . heap ) == 0","title":"is_empty()"},{"location":"aggregator_ref/#aggregator.TrendingHeap.is_full","text":"check if heap is full, meaning its length is the desired size Source code in src/aggregator.py def is_full ( self ): \"\"\" check if heap is full, meaning its length is the desired size \"\"\" return len ( self . heap ) == self . size","title":"is_full()"},{"location":"aggregator_ref/#aggregator.TrendingHeap.update","text":"update the heapdict, return true if changes, false if not return true if full and update happened Source code in src/aggregator.py def update ( self , key , score ): \"\"\" update the heapdict, return true if changes, false if not return true if full and update happened \"\"\" if self . contains ( key ): self . heap [ key ] = score return self . is_full () else : if not self . is_full (): self . heap [ key ] = score return self . is_full () else : if score > self . get_lowest_score (): self . heap . popitem () self . heap [ key ] = score return self . is_full () return False","title":"update()"}]}